/*
 * This file is the main driver for the Midnight MERC-20 CLI.
 * The entry point is the run function at the end of the file.
 * Startup files (e.g., testnet-remote.ts, standalone.ts) are expected to call run
 * with configuration specifying network addresses of required servers.
 */

import { createInterface, type Interface } from 'node:readline/promises';
import { stdin as input, stdout as output } from 'node:process';
import { WebSocket } from 'ws';
import { webcrypto } from 'crypto';
import {
  type MERC20Providers,
  type PrivateStates,
  MERC20API,
  utils,
  type MERC20DerivedState,
  type DeployedMERC20Contract,
} from 'midnight-erc20-port-api';
import { ledger, type Ledger } from 'midnight-erc20-port';
import {
  type BalancedTransaction,
  createBalancedTx,
  type MidnightProvider,
  type UnbalancedTransaction,
  type WalletProvider,
} from '@midnight-ntwrk/midnight-js-types';
import { type Wallet } from '@midnight-ntwrk/wallet-api';
import * as Rx from 'rxjs';
import { type CoinInfo, nativeToken, Transaction, type TransactionId } from '@midnight-ntwrk/ledger';
import { Transaction as ZswapTransaction } from '@midnight-ntwrk/zswap';
import { NodeZkConfigProvider } from '@midnight-ntwrk/midnight-js-node-zk-config-provider';
import { type Resource, WalletBuilder } from '@midnight-ntwrk/wallet';
import { indexerPublicDataProvider } from '@midnight-ntwrk/midnight-js-indexer-public-data-provider';
import { httpClientProofProvider } from '@midnight-ntwrk/midnight-js-http-client-proof-provider';
import { type Logger } from 'pino';
import { type Config, StandaloneConfig } from './config.js';
import type { StartedDockerComposeEnvironment, DockerComposeEnvironment } from 'testcontainers';
import { levelPrivateStateProvider } from '@midnight-ntwrk/midnight-js-level-private-state-provider';
import { type ContractAddress } from '@midnight-ntwrk/compact-runtime';
import { toHex } from '@midnight-ntwrk/midnight-js-utils';
import { getLedgerNetworkId, getZswapNetworkId } from '@midnight-ntwrk/midnight-js-network-id';

// @ts-expect-error: It's needed to make Scala.js and WASM code able to use cryptography
globalThis.crypto = webcrypto;

// @ts-expect-error: It's needed to enable WebSocket usage through apollo
globalThis.WebSocket = WebSocket;

/* **********************************************************************
 * getMerc20LedgerState: a helper that queries the current state of
 * the data on the ledger, for a specific merc-20 contract.
 * Note that the Ledger type returned here is not some generic,
 * abstract ledger object, but specifically the type generated by
 * the Compact compiler to correspond to the ledger declaration
 * in the merc-20 contract.
 */

export const getMERC20LedgerState = (
  providers: MERC20Providers,
  contractAddress: ContractAddress,
): Promise<Ledger | null> =>
  providers.publicDataProvider
    .queryContractState(contractAddress)
    .then((contractState) => (contractState != null ? ledger(contractState.data) : null));

/* **********************************************************************
 * deployOrJoin: returns a contract, by prompting the user about
 * whether to deploy a new one or join an existing one and then
 * calling the appropriate helper.
 */
const DEPLOY_OR_JOIN_QUESTION = `
You can do one of the following:
  1. Deploy a new MERC-20 contract
  2. Join an existing MERC-20 contract
  3. Exit
Which would you like to do? `;

const deployOrJoin = async (providers: MERC20Providers, rli: Interface, logger: Logger): Promise<MERC20API | null> => {
  let api: MERC20API | null = null;

  while (true) {
    const choice = await rli.question(DEPLOY_OR_JOIN_QUESTION);
    switch (choice) {
      case '1':
        const args = {
          tokenName: await rli.question('Enter token name: '),
          tokenSymbol: await rli.question('Enter token symbol: '),
          tokenDecimals: BigInt(await rli.question('Enter token decimals: ')),
          totalSupply: BigInt(await rli.question('Enter total supply: ')),
          mintAddress: await rli.question('Enter mint address (in hex): '), 
        };
        api = await MERC20API.deploy(providers, args, logger);
        logger.info(`Deployed contract at address: ${api.deployedContractAddress}`);
        return api;
      case '2':
        api = await MERC20API.join(providers, await rli.question('What is the contract address (in hex)? '), logger);
        logger.info(`Joined contract at address: ${api.deployedContractAddress}`);
        return api;
      case '3':
        logger.info('Exiting...');
        return null;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

/*
 * Displays the ledger state of the MERC-20 contract, including token metadata and total supply.
 */
const displayLedgerState = async (
  providers: MERC20Providers,
  deployedMerc20Contract: DeployedMERC20Contract,
  logger: Logger,
): Promise<void> => {
  const contractAddress = deployedMerc20Contract.deployTxData.public.contractAddress;
  const ledgerState = await getMERC20LedgerState(providers, contractAddress);
  if (ledgerState === null) {
    logger.info(`No MERC-20 contract deployed at ${contractAddress}`);
  } else {
    logger.info(`Token Name: ${ledgerState.tokenName}`);
    logger.info(`Token Symbol: ${ledgerState.tokenSymbol}`);
    logger.info(`Token Decimals: ${ledgerState.tokenDecimals}`);
    logger.info(`Total Supply: ${ledgerState.totalSupply}`);
  }
};

/*
 * Displays the private state, specifically the hex-formatted secret key.
 */
const displayPrivateState = async (providers: MERC20Providers, logger: Logger): Promise<void> => {
  const privateState = await providers.privateStateProvider.get('MERC20PrivateState');
  if (privateState === null) {
    logger.info(`No existing MERC-20 private state`);
  } else {
    logger.info(`Current secret key: ${toHex(privateState.secretKey)}`);
  }
};

/*
 * Displays derived state by combining ledger and private state.
 * Shows the user's balance as an example of derived state.
 */
const displayDerivedState = (derivedState: MERC20DerivedState | undefined, logger: Logger) => {
  if (derivedState === undefined) {
    logger.info(`No MERC-20 state currently available`);
  } else {
    logger.info(`Your balance: ${derivedState.userBalance}`);
  }
};

/*
 * Main interactive menu for the MERC-20 CLI.
 * Starts by prompting to deploy or join a contract, then offers ERC-20 operations.
 */
const MAIN_LOOP_QUESTION = `
You can do one of the following:
  1. Transfer tokens
  2. Approve a spender
  3. Transfer from (using allowance)
  4. Check balance
  5. Check allowance
  6. Display token metadata
  7. Exit
Which would you like to do? `;

const mainLoop = async (providers: MERC20Providers, rli: Interface, logger: Logger): Promise<void> => {
  const merc20Api = await deployOrJoin(providers, rli, logger);
  if (merc20Api === null) return;

  let currentState: MERC20DerivedState | undefined;
  const stateObserver = {
    next: (state: MERC20DerivedState) => (currentState = state),
  };
  const subscription = merc20Api.state$.subscribe(stateObserver);

  try {
    while (true) {
      const choice = await rli.question(MAIN_LOOP_QUESTION);
      switch (choice) {
        case '1': {
          const to = await rli.question('Enter recipient address (in hex): ');
          const amount = await rli.question('Enter amount to transfer: ');
          await merc20Api.transfer(to, BigInt(amount));
          logger.info(`Transferred ${amount} tokens to ${to}`);
          break;
        }
        case '2': {
          const spender = await rli.question('Enter spender address (in hex): ');
          const amount = await rli.question('Enter amount to approve: ');
          await merc20Api.approve(spender, BigInt(amount));
          logger.info(`Approved ${spender} to spend ${amount} tokens`);
          break;
        }
        case '3': {
          const from = await rli.question('Enter from address (in hex): ');
          const to = await rli.question('Enter to address (in hex): ');
          const amount = await rli.question('Enter amount to transfer: ');
          await merc20Api.transferFrom(from, to, BigInt(amount));
          logger.info(`Transferred ${amount} tokens from ${from} to ${to}`);
          break;
        }
        case '4': {
          const address = await rli.question('Enter address to check balance (in hex): ');
          const balance = await merc20Api.balanceOf(address);
          logger.info(`Balance of ${address}: ${balance}`);
          break;
        }
        case '5': {
          const owner = await rli.question('Enter owner address (in hex): ');
          const spender = await rli.question('Enter spender address (in hex): ');
          const allowance = await merc20Api.allowance(owner, spender);
          logger.info(`Allowance of ${spender} for ${owner}: ${allowance}`);
          break;
        }
        case '6':
          await displayLedgerState(providers, merc20Api.deployedContract, logger);
          break;
        case '7':
          logger.info('Exiting...');
          return;
        default:
          logger.error(`Invalid choice: ${choice}`);
      }
    }
  } finally {
    subscription.unsubscribe();
  }
};

/*
 * Creates an object satisfying both WalletProvider and MidnightProvider interfaces,
 * implemented using the provided wallet.
 */
const createWalletAndMidnightProvider = async (wallet: Wallet): Promise<WalletProvider & MidnightProvider> => {
  const state = await Rx.firstValueFrom(wallet.state());
  return {
    coinPublicKey: state.coinPublicKey,
    balanceTx(tx: UnbalancedTransaction, newCoins: CoinInfo[]): Promise<BalancedTransaction> {
      return wallet
        .balanceTransaction(
          ZswapTransaction.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()),
          newCoins,
        )
        .then((tx) => wallet.proveTransaction(tx))
        .then((zswapTx) => Transaction.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId()))
        .then(createBalancedTx);
    },
    submitTx(tx: BalancedTransaction): Promise<TransactionId> {
      return wallet.submitTransaction(tx);
    },
  };
};

/*
 * Waits for tokens to appear in the wallet by monitoring its state stream.
 */
const waitForFunds = (wallet: Wallet, logger: Logger) =>
  Rx.firstValueFrom(
    wallet.state().pipe(
      Rx.throttleTime(10_000),
      Rx.tap((state) => {
        const scanned = state.syncProgress?.synced ?? 0n;
        const total = state.syncProgress?.total.toString() ?? 'unknown number';
        logger.info(`Wallet processed ${scanned} indices out of ${total}`);
      }),
      Rx.filter((state) => {
        const synced = state.syncProgress?.synced ?? 0n;
        const total = state.syncProgress?.total ?? 1_000n;
        return total - synced < 100n;
      }),
      Rx.map((s) => s.balances[nativeToken()] ?? 0n),
      Rx.filter((balance) => balance > 0n),
    ),
  );

/*
 * Builds a wallet and waits for tokens to appear in it.
 */
const buildWalletAndWaitForFunds = async (
  { indexer, indexerWS, node, proofServer }: Config,
  logger: Logger,
  seed: string,
): Promise<Wallet & Resource> => {
  const wallet = await WalletBuilder.buildFromSeed(
    indexer,
    indexerWS,
    proofServer,
    node,
    seed,
    getZswapNetworkId(),
    'warn',
  );
  wallet.start();
  const state = await Rx.firstValueFrom(wallet.state());
  logger.info(`Your wallet seed: ${seed}`);
  logger.info(`Your wallet address: ${state.address}`);
  let balance = state.balances[nativeToken()];
  if (balance === undefined || balance === 0n) {
    logger.info(`Your wallet balance: 0`);
    logger.info(`Waiting to receive tokens...`);
    balance = await waitForFunds(wallet, logger);
  }
  logger.info(`Your wallet balance: ${balance}`);
  return wallet;
};

// Builds a wallet with a random seed
const buildFreshWallet = async (config: Config, logger: Logger): Promise<Wallet & Resource> =>
  await buildWalletAndWaitForFunds(config, logger, toHex(utils.randomBytes(32)));

// Builds a wallet from a user-provided seed
const buildWalletFromSeed = async (config: Config, rli: Interface, logger: Logger): Promise<Wallet & Resource> => {
  const seed = await rli.question('Enter your wallet seed: ');
  return await buildWalletAndWaitForFunds(config, logger, seed);
};

/*
 * Prompts the user to create a new wallet or use an existing seed,
 * unless running in standalone mode where a genesis seed is used.
 */
const WALLET_LOOP_QUESTION = `
You can do one of the following:
  1. Build a fresh wallet
  2. Build wallet from a seed
  3. Exit
Which would you like to do? `;

const buildWallet = async (config: Config, rli: Interface, logger: Logger): Promise<(Wallet & Resource) | null> => {
  if (config instanceof StandaloneConfig) {
    return await buildWalletAndWaitForFunds(config, logger, '0000000000000000000000000000000000000000000000000000000000000001');
  }
  while (true) {
    const choice = await rli.question(WALLET_LOOP_QUESTION);
    switch (choice) {
      case '1':
        return await buildFreshWallet(config, logger);
      case '2':
        return await buildWalletFromSeed(config, rli, logger);
      case '3':
        logger.info('Exiting...');
        return null;
      default:
        logger.error(`Invalid choice: ${choice}`);
    }
  }
};

/*
 * Maps container ports for Docker environment setup.
 */
const mapContainerPort = (env: StartedDockerComposeEnvironment, url: string, containerName: string) => {
  const mappedUrl = new URL(url);
  const container = env.getContainer(containerName);
  mappedUrl.port = String(container.getFirstMappedPort());
  return mappedUrl.toString().replace(/\/+$/, '');
};

/*
 * Main entry point for the MERC-20 CLI.
 * Waits for Docker to be ready if provided, then initializes the wallet and starts the CLI.
 */
export const run = async (config: Config, logger: Logger, dockerEnv?: DockerComposeEnvironment): Promise<void> => {
  const rli = createInterface({ input, output, terminal: true });
  let env;
  if (dockerEnv !== undefined) {
    env = await dockerEnv.up();
    if (config instanceof StandaloneConfig) {
      config.indexer = mapContainerPort(env, config.indexer, 'merc20-indexer');
      config.indexerWS = mapContainerPort(env, config.indexerWS, 'merc20-indexer');
      config.node = mapContainerPort(env, config.node, 'merc20-node');
      config.proofServer = mapContainerPort(env, config.proofServer, 'merc20-proof-server');
    }
  }
  const wallet = await buildWallet(config, rli, logger);
  try {
    if (wallet !== null) {
      const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
      const providers = {
        privateStateProvider: levelPrivateStateProvider<PrivateStates>({
          privateStateStoreName: config.privateStateStoreName,
        }),
        publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),
        zkConfigProvider: new NodeZkConfigProvider<'transfer' | 'approve' | 'transferFrom'>(config.zkConfigPath),
        proofProvider: httpClientProofProvider(config.proofServer),
        walletProvider: walletAndMidnightProvider,
        midnightProvider: walletAndMidnightProvider,
      };
      await mainLoop(providers, rli, logger);
    }
  } catch (e) {
    if (e instanceof Error) {
      logger.error(`Error: ${e.message}`);
      logger.info('Exiting...');
      logger.debug(`${e.stack}`);
    } else {
      throw e;
    }
  } finally {
    try {
      rli.close();
      rli.removeAllListeners();
    } catch (e) {
    } finally {
      try {
        if (wallet !== null) await wallet.close();
      } catch (e) {
      } finally {
        if (env !== undefined) {
          await env.down();
          logger.info('Goodbye');
          process.exit(0);
        }
      }
    }
  }
};